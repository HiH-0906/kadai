#include "EnemyMove.h"
#include <_DebugConOut.h>
#include <cmath>
#include "_DebugDispOut.h"
#include <SceneMng.h>

int EnemyMove::_InCount = 0;
// 敵最大数設定
int EnemyMove::_enemyMax = ENEMY_MAX;
EnemyMove::EnemyMove(Vector2Dbl & pos,double & rad,int &speed,bool &flag): _pos(pos),_rad(rad),_atackFlag(flag)			// 参照は存在してないといけないのでここに書く
{
	_move = nullptr;
	_aimCnt = -1;
}

EnemyMove::~EnemyMove()
{
}

void EnemyMove::Update(sharedObj plObj)
{
	_plPos = (*plObj).pos();
	// 中身ﾁｪｯｸ
	if (_move != nullptr)
	{
		// 呼び出し
		(this->*_move)();
	}
}


void EnemyMove::InCount(void)
{
	_InCount++;
}

MOVE_TYPE EnemyMove::aimMove(void)
{
	if (_aim.size() <= _aimCnt)
	{
		return MOVE_TYPE::WAIT;
	}
	return _aim[_aimCnt].first;
}


bool EnemyMove::SetMoveState(MoveState & state, bool newFlag)
{
	if (newFlag)
	{
		// 中身を消す
		_aim.clear();
	}
	_aim = std::move(state);		// ｺﾋﾟｰを作りたくないので所有権譲渡
	
	if (newFlag)
	{
		// 切り替え
		SetMovePrg();
	}

	return true;
}

void EnemyMove::SetMovePrg(void)
{
	_aimCnt++;
	auto checkAim = [&]() 
	{
		for (_aimCnt = 0;_aimCnt<_aim.size();_aimCnt++)
		{
			if (_aim[_aimCnt].first == MOVE_TYPE::SCALE)
			{
				return true;
			}
		}
		return false;
	};

	// 範囲ﾁｪｯｸ
	if (_aim.size() <= _aimCnt)
	{
		if (!checkAim())
		{
			// 範囲外ならreturn
			return;
		}
	}
	if (_pos.y > lpSceneMng.GameScreenSize.y)
	{
		_pos.y = -100.0;
	}
	// ｽﾀｰﾄ位置保存
	_startPos = _pos;
	// 目的地保存
	_endPos = _aim[_aimCnt].second;

	// bimCntに合わせて_moveの中身変更
	switch (_aim[_aimCnt].first)
	{
	case MOVE_TYPE::WAIT:
		_move = &EnemyMove::Wait;
		// waitで使う変数の初期化
		_count = 0;
		break;
	case MOVE_TYPE::SIGMOID:
		_move = &EnemyMove::MoveSigmoid;
		// 幅
		_moveGain = -5.0;
		// 目的地までの距離
		_lenght = _endPos - _startPos;
		_lenght.x /= 60.0;
		_oldPos = _pos;
		break;
	case MOVE_TYPE::SPIRAL:
		_move = &EnemyMove::MoveSpiral;
		// 角度決め
		_cntRad = 0.0;
		_tmpRad = PI * _endPos.y;
		_moveRad = PI / 20.0*_endPos.x*(1-(2*_endPos.y));
		// 円の中心決め
		radius = 64.0;
		_endPos.y = _pos.y - radius + (radius*2.0 *_endPos.y);
		_endPos.x = _pos.x;
		break;
	case MOVE_TYPE::PITIN:
		_move = &EnemyMove::PitIn;
		if (_startPos.y > 0)
		{
			//_endPos.x += (std::abs((lpSceneMng.fCnt + 60) % 100 - 50)-25);
			_endPos.x += (lpSceneMng.fCnt + 60) % 150 * (1 - (2 * (((lpSceneMng.fCnt + 60) / 150) % 2))) + (150 * (((lpSceneMng.fCnt + 60) / 150) % 2));
		}
		// 2点間
		_lenght = _endPos - _pos;
		// 1ﾌﾚｰﾑに進む距離
		_oneMoveVec = (_endPos - _startPos) / 60.0;
		_count = 0;
		break;
	case MOVE_TYPE::LR:
		_count = 0;
		_move = &EnemyMove::MoveLR;
		_InCount++;
		break;
	case MOVE_TYPE::SCALE:
		_move = &EnemyMove::MoveScale;
		_center = _endPos;
		_range = _center - _pos;
		_nextRange = _range * 1.3;
		_oneMoveRange = (_range - _nextRange) / 60.0;
		_count = 0;
		break;
	case MOVE_TYPE::ATACK:
		_move = &EnemyMove::MoveAtack;
		_count = 0;
		break;
	default:
		AST();
		_move = &EnemyMove::Wait;
		break;
	}
}

void EnemyMove::MoveSigmoid(void)
{
	_oldPos = _pos;
	if (5 - _moveGain >= 0.05)
	{
		// x係数
		_moveGain += 10.0 / 60.0;
		// ｼｸﾞﾓｲﾄﾞ関数によって得た値を拡大
		_pos.y = _startPos.y + 1.0 / (1.0 + exp(-1.3*_moveGain-1.0)) * _lenght.y;
		_pos.x = _pos.x + _lenght.x;
		_rad = atan2(_pos.y - _oldPos.y, _pos.x - _oldPos.x) + PI / 2;
	}
	else
	{
		// 位置強制
		_pos = _endPos;
		SetMovePrg();
	}
}

void EnemyMove::MoveSpiral(void)
{
	_oldPos = _pos;
	if (PI*4.0 - abs(_cntRad) > 0)
	{
		// 円のスタート位置ずらしのためのcos,sin逆転
		_pos.y = _endPos.y + radius * std::cos(_tmpRad);
		_pos.x = _endPos.x + radius * std::sin(_tmpRad);
		// ｷｬﾗの向いている方向決め
		_rad = atan2(_pos.y - _oldPos.y, _pos.x - _oldPos.x) + PI / 2;
		radius -= 0.5;
		_tmpRad += _moveRad;
		_cntRad += abs(_moveRad);
	}
	else
	{
		SetMovePrg();
		TREACE("Spairal終了だよー\n");
	}
}

void EnemyMove::PitIn(void)
{
	// 1 ﾌﾚｰﾑに進む距離より_endPosまでの距離が短いなら移動終了
	if (_count < 60)
	{
		_pos += _oneMoveVec;
		_rad = atan2(_lenght.y, _lenght.x) + PI / 2.0;
	}
	else
	{
		// 位置矯正
		_pos = _endPos;
		_rad = 0.0;
		// 行動切り替え
		SetMovePrg();
		// 一応切り替え表示
		TREACE("Pitin終了だよー\n");
	}
	_count++;
}

void EnemyMove::Wait(void)
{
	// ｶｳﾝﾄが行動開始する値まで来ているかﾁｪｯｸ　secondのxを行動開始するｶｳﾝﾄとして扱う
	if (_count >= _endPos.x)
	{
		// 行動の切り替え
		SetMovePrg();
		// 一応切り替え表示
		TREACE("Wait終了だよー\n");
	}
	// ｶｳﾝﾄの増加
	_count++;
}

void EnemyMove::MoveLR(void)
{
	//_pos.x = _endPos.x + (std::abs(lpSceneMng.fCnt % 100 - 50) - 25);
	_pos.x = _endPos.x + lpSceneMng.fCnt % 150 * (1 - (2 * ((lpSceneMng.fCnt / 150) % 2)))+(150* ((lpSceneMng.fCnt / 150) % 2));
	if (_InCount >= _enemyMax && lpSceneMng.fCnt % 150 == 74)
	{
		SetMovePrg();
		startFlam = lpSceneMng.fCnt;
		TREACE("LR終了だよー\n");
	}
}

void EnemyMove::MoveScale(void)
{
	//_pos = _startPos + _lenght * static_cast<double>(((lpSceneMng.fCnt % 30 * (1 - (2 * ((lpSceneMng.fCnt / 30) % 2))) + (30 * ((lpSceneMng.fCnt / 30) % 2)) + 100) / 100));
	_pos += _oneMoveRange * (1.0 - (2.0 * ((_count / 60) % 2)));
	if (_atackFlag)
	{
		SetMovePrg();
		_atackFlag = false;
		TREACE("Scale終了だよー\n");
	}
	_count++;
}

void EnemyMove::MoveAtack(void)
{
	if (_count < 60)
	{
		_rad += PI / 10;
	}
	else
	{
		_move = &EnemyMove::PitIn;
		_endPos = _plPos + Vector2Dbl{ 0.0, 100.0 };
		// 2点間
		_lenght = _endPos - _pos;
		// 1ﾌﾚｰﾑに進む距離
		_oneMoveVec = _lenght / 60.0;
		_count = 0;
	}
	_count++;
}
